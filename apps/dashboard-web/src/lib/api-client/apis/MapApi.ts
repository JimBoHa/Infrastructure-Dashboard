/* tslint:disable */
/* eslint-disable */
/**
 * Infrastructure Dashboard Core Server
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  MapFeatureResponse,
  MapFeatureUpsertRequest,
  MapLayerResponse,
  MapLayerUpsertRequest,
  MapSaveCreateRequest,
  MapSaveResponse,
  MapSettingsResponse,
  MapSettingsUpdateRequest,
  OfflineMapPackResponse,
} from '../models/index';
import {
    MapFeatureResponseFromJSON,
    MapFeatureResponseToJSON,
    MapFeatureUpsertRequestFromJSON,
    MapFeatureUpsertRequestToJSON,
    MapLayerResponseFromJSON,
    MapLayerResponseToJSON,
    MapLayerUpsertRequestFromJSON,
    MapLayerUpsertRequestToJSON,
    MapSaveCreateRequestFromJSON,
    MapSaveCreateRequestToJSON,
    MapSaveResponseFromJSON,
    MapSaveResponseToJSON,
    MapSettingsResponseFromJSON,
    MapSettingsResponseToJSON,
    MapSettingsUpdateRequestFromJSON,
    MapSettingsUpdateRequestToJSON,
    OfflineMapPackResponseFromJSON,
    OfflineMapPackResponseToJSON,
} from '../models/index';

export interface ApplyMapSaveRequest {
    id: number;
}

export interface CreateMapFeatureRequest {
    mapFeatureUpsertRequest: MapFeatureUpsertRequest;
}

export interface CreateMapLayerRequest {
    mapLayerUpsertRequest: MapLayerUpsertRequest;
}

export interface CreateMapSaveRequest {
    mapSaveCreateRequest: MapSaveCreateRequest;
}

export interface DeleteMapFeatureRequest {
    id: number;
}

export interface DeleteMapLayerRequest {
    id: number;
}

export interface GetGlyphRangeRequest {
    fontstack: string;
    range: string;
}

export interface GetOfflinePackRequest {
    id: string;
}

export interface GetOfflineTileRequest {
    pack: string;
    layer: string;
    z: number;
    x: number;
    y: number;
}

export interface InstallOfflinePackRequest {
    id: string;
}

export interface UpdateMapFeatureRequest {
    id: number;
    mapFeatureUpsertRequest: MapFeatureUpsertRequest;
}

export interface UpdateMapLayerRequest {
    id: number;
    mapLayerUpsertRequest: MapLayerUpsertRequest;
}

export interface UpdateMapSettingsRequest {
    mapSettingsUpdateRequest: MapSettingsUpdateRequest;
}

/**
 * 
 */
export class MapApi extends runtime.BaseAPI {

    /**
     * Creates request options for applyMapSave without sending the request
     */
    async applyMapSaveRequestOpts(requestParameters: ApplyMapSaveRequest): Promise<runtime.RequestOpts> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling applyMapSave().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/map/saves/{id}/apply`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        return {
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        };
    }

    /**
     */
    async applyMapSaveRaw(requestParameters: ApplyMapSaveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MapSettingsResponse>> {
        const requestOptions = await this.applyMapSaveRequestOpts(requestParameters);
        const response = await this.request(requestOptions, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MapSettingsResponseFromJSON(jsonValue));
    }

    /**
     */
    async applyMapSave(requestParameters: ApplyMapSaveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MapSettingsResponse> {
        const response = await this.applyMapSaveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates request options for createMapFeature without sending the request
     */
    async createMapFeatureRequestOpts(requestParameters: CreateMapFeatureRequest): Promise<runtime.RequestOpts> {
        if (requestParameters['mapFeatureUpsertRequest'] == null) {
            throw new runtime.RequiredError(
                'mapFeatureUpsertRequest',
                'Required parameter "mapFeatureUpsertRequest" was null or undefined when calling createMapFeature().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/map/features`;

        return {
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: MapFeatureUpsertRequestToJSON(requestParameters['mapFeatureUpsertRequest']),
        };
    }

    /**
     */
    async createMapFeatureRaw(requestParameters: CreateMapFeatureRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MapFeatureResponse>> {
        const requestOptions = await this.createMapFeatureRequestOpts(requestParameters);
        const response = await this.request(requestOptions, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MapFeatureResponseFromJSON(jsonValue));
    }

    /**
     */
    async createMapFeature(requestParameters: CreateMapFeatureRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MapFeatureResponse> {
        const response = await this.createMapFeatureRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates request options for createMapLayer without sending the request
     */
    async createMapLayerRequestOpts(requestParameters: CreateMapLayerRequest): Promise<runtime.RequestOpts> {
        if (requestParameters['mapLayerUpsertRequest'] == null) {
            throw new runtime.RequiredError(
                'mapLayerUpsertRequest',
                'Required parameter "mapLayerUpsertRequest" was null or undefined when calling createMapLayer().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/map/layers`;

        return {
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: MapLayerUpsertRequestToJSON(requestParameters['mapLayerUpsertRequest']),
        };
    }

    /**
     */
    async createMapLayerRaw(requestParameters: CreateMapLayerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MapLayerResponse>> {
        const requestOptions = await this.createMapLayerRequestOpts(requestParameters);
        const response = await this.request(requestOptions, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MapLayerResponseFromJSON(jsonValue));
    }

    /**
     */
    async createMapLayer(requestParameters: CreateMapLayerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MapLayerResponse> {
        const response = await this.createMapLayerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates request options for createMapSave without sending the request
     */
    async createMapSaveRequestOpts(requestParameters: CreateMapSaveRequest): Promise<runtime.RequestOpts> {
        if (requestParameters['mapSaveCreateRequest'] == null) {
            throw new runtime.RequiredError(
                'mapSaveCreateRequest',
                'Required parameter "mapSaveCreateRequest" was null or undefined when calling createMapSave().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/map/saves`;

        return {
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: MapSaveCreateRequestToJSON(requestParameters['mapSaveCreateRequest']),
        };
    }

    /**
     */
    async createMapSaveRaw(requestParameters: CreateMapSaveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MapSaveResponse>> {
        const requestOptions = await this.createMapSaveRequestOpts(requestParameters);
        const response = await this.request(requestOptions, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MapSaveResponseFromJSON(jsonValue));
    }

    /**
     */
    async createMapSave(requestParameters: CreateMapSaveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MapSaveResponse> {
        const response = await this.createMapSaveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates request options for deleteMapFeature without sending the request
     */
    async deleteMapFeatureRequestOpts(requestParameters: DeleteMapFeatureRequest): Promise<runtime.RequestOpts> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling deleteMapFeature().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/map/features/{id}`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        return {
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        };
    }

    /**
     */
    async deleteMapFeatureRaw(requestParameters: DeleteMapFeatureRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const requestOptions = await this.deleteMapFeatureRequestOpts(requestParameters);
        const response = await this.request(requestOptions, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async deleteMapFeature(requestParameters: DeleteMapFeatureRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteMapFeatureRaw(requestParameters, initOverrides);
    }

    /**
     * Creates request options for deleteMapLayer without sending the request
     */
    async deleteMapLayerRequestOpts(requestParameters: DeleteMapLayerRequest): Promise<runtime.RequestOpts> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling deleteMapLayer().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/map/layers/{id}`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        return {
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        };
    }

    /**
     */
    async deleteMapLayerRaw(requestParameters: DeleteMapLayerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const requestOptions = await this.deleteMapLayerRequestOpts(requestParameters);
        const response = await this.request(requestOptions, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async deleteMapLayer(requestParameters: DeleteMapLayerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteMapLayerRaw(requestParameters, initOverrides);
    }

    /**
     * Creates request options for getGlyphRange without sending the request
     */
    async getGlyphRangeRequestOpts(requestParameters: GetGlyphRangeRequest): Promise<runtime.RequestOpts> {
        if (requestParameters['fontstack'] == null) {
            throw new runtime.RequiredError(
                'fontstack',
                'Required parameter "fontstack" was null or undefined when calling getGlyphRange().'
            );
        }

        if (requestParameters['range'] == null) {
            throw new runtime.RequiredError(
                'range',
                'Required parameter "range" was null or undefined when calling getGlyphRange().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/api/map/glyphs/{fontstack}/{range}`;
        urlPath = urlPath.replace(`{${"fontstack"}}`, encodeURIComponent(String(requestParameters['fontstack'])));
        urlPath = urlPath.replace(`{${"range"}}`, encodeURIComponent(String(requestParameters['range'])));

        return {
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        };
    }

    /**
     */
    async getGlyphRangeRaw(requestParameters: GetGlyphRangeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const requestOptions = await this.getGlyphRangeRequestOpts(requestParameters);
        const response = await this.request(requestOptions, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async getGlyphRange(requestParameters: GetGlyphRangeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.getGlyphRangeRaw(requestParameters, initOverrides);
    }

    /**
     * Creates request options for getMapSettings without sending the request
     */
    async getMapSettingsRequestOpts(): Promise<runtime.RequestOpts> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/api/map/settings`;

        return {
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        };
    }

    /**
     */
    async getMapSettingsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MapSettingsResponse>> {
        const requestOptions = await this.getMapSettingsRequestOpts();
        const response = await this.request(requestOptions, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MapSettingsResponseFromJSON(jsonValue));
    }

    /**
     */
    async getMapSettings(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MapSettingsResponse> {
        const response = await this.getMapSettingsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Creates request options for getOfflinePack without sending the request
     */
    async getOfflinePackRequestOpts(requestParameters: GetOfflinePackRequest): Promise<runtime.RequestOpts> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getOfflinePack().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/api/map/offline/packs/{id}`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        return {
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        };
    }

    /**
     */
    async getOfflinePackRaw(requestParameters: GetOfflinePackRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<OfflineMapPackResponse>> {
        const requestOptions = await this.getOfflinePackRequestOpts(requestParameters);
        const response = await this.request(requestOptions, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OfflineMapPackResponseFromJSON(jsonValue));
    }

    /**
     */
    async getOfflinePack(requestParameters: GetOfflinePackRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<OfflineMapPackResponse> {
        const response = await this.getOfflinePackRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates request options for getOfflineTile without sending the request
     */
    async getOfflineTileRequestOpts(requestParameters: GetOfflineTileRequest): Promise<runtime.RequestOpts> {
        if (requestParameters['pack'] == null) {
            throw new runtime.RequiredError(
                'pack',
                'Required parameter "pack" was null or undefined when calling getOfflineTile().'
            );
        }

        if (requestParameters['layer'] == null) {
            throw new runtime.RequiredError(
                'layer',
                'Required parameter "layer" was null or undefined when calling getOfflineTile().'
            );
        }

        if (requestParameters['z'] == null) {
            throw new runtime.RequiredError(
                'z',
                'Required parameter "z" was null or undefined when calling getOfflineTile().'
            );
        }

        if (requestParameters['x'] == null) {
            throw new runtime.RequiredError(
                'x',
                'Required parameter "x" was null or undefined when calling getOfflineTile().'
            );
        }

        if (requestParameters['y'] == null) {
            throw new runtime.RequiredError(
                'y',
                'Required parameter "y" was null or undefined when calling getOfflineTile().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/api/map/tiles/{pack}/{layer}/{z}/{x}/{y}`;
        urlPath = urlPath.replace(`{${"pack"}}`, encodeURIComponent(String(requestParameters['pack'])));
        urlPath = urlPath.replace(`{${"layer"}}`, encodeURIComponent(String(requestParameters['layer'])));
        urlPath = urlPath.replace(`{${"z"}}`, encodeURIComponent(String(requestParameters['z'])));
        urlPath = urlPath.replace(`{${"x"}}`, encodeURIComponent(String(requestParameters['x'])));
        urlPath = urlPath.replace(`{${"y"}}`, encodeURIComponent(String(requestParameters['y'])));

        return {
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        };
    }

    /**
     */
    async getOfflineTileRaw(requestParameters: GetOfflineTileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const requestOptions = await this.getOfflineTileRequestOpts(requestParameters);
        const response = await this.request(requestOptions, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async getOfflineTile(requestParameters: GetOfflineTileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.getOfflineTileRaw(requestParameters, initOverrides);
    }

    /**
     * Creates request options for installOfflinePack without sending the request
     */
    async installOfflinePackRequestOpts(requestParameters: InstallOfflinePackRequest): Promise<runtime.RequestOpts> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling installOfflinePack().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/map/offline/packs/{id}/install`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        return {
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        };
    }

    /**
     */
    async installOfflinePackRaw(requestParameters: InstallOfflinePackRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<OfflineMapPackResponse>> {
        const requestOptions = await this.installOfflinePackRequestOpts(requestParameters);
        const response = await this.request(requestOptions, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OfflineMapPackResponseFromJSON(jsonValue));
    }

    /**
     */
    async installOfflinePack(requestParameters: InstallOfflinePackRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<OfflineMapPackResponse> {
        const response = await this.installOfflinePackRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates request options for listMapFeatures without sending the request
     */
    async listMapFeaturesRequestOpts(): Promise<runtime.RequestOpts> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/api/map/features`;

        return {
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        };
    }

    /**
     */
    async listMapFeaturesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<MapFeatureResponse>>> {
        const requestOptions = await this.listMapFeaturesRequestOpts();
        const response = await this.request(requestOptions, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(MapFeatureResponseFromJSON));
    }

    /**
     */
    async listMapFeatures(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<MapFeatureResponse>> {
        const response = await this.listMapFeaturesRaw(initOverrides);
        return await response.value();
    }

    /**
     * Creates request options for listMapLayers without sending the request
     */
    async listMapLayersRequestOpts(): Promise<runtime.RequestOpts> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/api/map/layers`;

        return {
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        };
    }

    /**
     */
    async listMapLayersRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<MapLayerResponse>>> {
        const requestOptions = await this.listMapLayersRequestOpts();
        const response = await this.request(requestOptions, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(MapLayerResponseFromJSON));
    }

    /**
     */
    async listMapLayers(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<MapLayerResponse>> {
        const response = await this.listMapLayersRaw(initOverrides);
        return await response.value();
    }

    /**
     * Creates request options for listMapSaves without sending the request
     */
    async listMapSavesRequestOpts(): Promise<runtime.RequestOpts> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/api/map/saves`;

        return {
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        };
    }

    /**
     */
    async listMapSavesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<MapSaveResponse>>> {
        const requestOptions = await this.listMapSavesRequestOpts();
        const response = await this.request(requestOptions, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(MapSaveResponseFromJSON));
    }

    /**
     */
    async listMapSaves(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<MapSaveResponse>> {
        const response = await this.listMapSavesRaw(initOverrides);
        return await response.value();
    }

    /**
     * Creates request options for listOfflinePacks without sending the request
     */
    async listOfflinePacksRequestOpts(): Promise<runtime.RequestOpts> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/api/map/offline/packs`;

        return {
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        };
    }

    /**
     */
    async listOfflinePacksRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<OfflineMapPackResponse>>> {
        const requestOptions = await this.listOfflinePacksRequestOpts();
        const response = await this.request(requestOptions, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(OfflineMapPackResponseFromJSON));
    }

    /**
     */
    async listOfflinePacks(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<OfflineMapPackResponse>> {
        const response = await this.listOfflinePacksRaw(initOverrides);
        return await response.value();
    }

    /**
     * Creates request options for updateMapFeature without sending the request
     */
    async updateMapFeatureRequestOpts(requestParameters: UpdateMapFeatureRequest): Promise<runtime.RequestOpts> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling updateMapFeature().'
            );
        }

        if (requestParameters['mapFeatureUpsertRequest'] == null) {
            throw new runtime.RequiredError(
                'mapFeatureUpsertRequest',
                'Required parameter "mapFeatureUpsertRequest" was null or undefined when calling updateMapFeature().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/map/features/{id}`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        return {
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: MapFeatureUpsertRequestToJSON(requestParameters['mapFeatureUpsertRequest']),
        };
    }

    /**
     */
    async updateMapFeatureRaw(requestParameters: UpdateMapFeatureRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MapFeatureResponse>> {
        const requestOptions = await this.updateMapFeatureRequestOpts(requestParameters);
        const response = await this.request(requestOptions, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MapFeatureResponseFromJSON(jsonValue));
    }

    /**
     */
    async updateMapFeature(requestParameters: UpdateMapFeatureRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MapFeatureResponse> {
        const response = await this.updateMapFeatureRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates request options for updateMapLayer without sending the request
     */
    async updateMapLayerRequestOpts(requestParameters: UpdateMapLayerRequest): Promise<runtime.RequestOpts> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling updateMapLayer().'
            );
        }

        if (requestParameters['mapLayerUpsertRequest'] == null) {
            throw new runtime.RequiredError(
                'mapLayerUpsertRequest',
                'Required parameter "mapLayerUpsertRequest" was null or undefined when calling updateMapLayer().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/map/layers/{id}`;
        urlPath = urlPath.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id'])));

        return {
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: MapLayerUpsertRequestToJSON(requestParameters['mapLayerUpsertRequest']),
        };
    }

    /**
     */
    async updateMapLayerRaw(requestParameters: UpdateMapLayerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MapLayerResponse>> {
        const requestOptions = await this.updateMapLayerRequestOpts(requestParameters);
        const response = await this.request(requestOptions, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MapLayerResponseFromJSON(jsonValue));
    }

    /**
     */
    async updateMapLayer(requestParameters: UpdateMapLayerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MapLayerResponse> {
        const response = await this.updateMapLayerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates request options for updateMapSettings without sending the request
     */
    async updateMapSettingsRequestOpts(requestParameters: UpdateMapSettingsRequest): Promise<runtime.RequestOpts> {
        if (requestParameters['mapSettingsUpdateRequest'] == null) {
            throw new runtime.RequiredError(
                'mapSettingsUpdateRequest',
                'Required parameter "mapSettingsUpdateRequest" was null or undefined when calling updateMapSettings().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/map/settings`;

        return {
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: MapSettingsUpdateRequestToJSON(requestParameters['mapSettingsUpdateRequest']),
        };
    }

    /**
     */
    async updateMapSettingsRaw(requestParameters: UpdateMapSettingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MapSettingsResponse>> {
        const requestOptions = await this.updateMapSettingsRequestOpts(requestParameters);
        const response = await this.request(requestOptions, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MapSettingsResponseFromJSON(jsonValue));
    }

    /**
     */
    async updateMapSettings(requestParameters: UpdateMapSettingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MapSettingsResponse> {
        const response = await this.updateMapSettingsRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
